// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/gogo/protobuf/types"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = types.DynamicAny{}
)

// define the regex for a UUID once up-front
var _gateway_configuration_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// ValidateFields checks the field values on LBTChannelConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LBTChannelConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LBTChannelConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "frequency":
			// no validation rules for Frequency
		case "scan_time_microseconds":
			// no validation rules for ScanTimeMicroseconds
		default:
			return LBTChannelConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LBTChannelConfigValidationError is the validation error returned by
// LBTChannelConfig.ValidateFields if the designated constraints aren't met.
type LBTChannelConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LBTChannelConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LBTChannelConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LBTChannelConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LBTChannelConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LBTChannelConfigValidationError) ErrorName() string { return "LBTChannelConfigValidationError" }

// Error satisfies the builtin error interface
func (e LBTChannelConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLBTChannelConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LBTChannelConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LBTChannelConfigValidationError{}

// ValidateFields checks the field values on LBTConfig with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *LBTConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LBTConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "enable":
			// no validation rules for Enable
		case "rssi_target":
			// no validation rules for RssiTarget
		case "channel_configs":

			for idx, item := range m.GetChannelConfigs() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return LBTConfigValidationError{
							field:  fmt.Sprintf("channel_configs[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "rssi_offset":
			// no validation rules for RssiOffset
		default:
			return LBTConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LBTConfigValidationError is the validation error returned by
// LBTConfig.ValidateFields if the designated constraints aren't met.
type LBTConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LBTConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LBTConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LBTConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LBTConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LBTConfigValidationError) ErrorName() string { return "LBTConfigValidationError" }

// Error satisfies the builtin error interface
func (e LBTConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLBTConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LBTConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LBTConfigValidationError{}

// ValidateFields checks the field values on RFConfig with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *RFConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = RFConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "enable":
			// no validation rules for Enable
		case "type":
			// no validation rules for Type
		case "frequency":
			// no validation rules for Frequency
		case "rssi_offset":
			// no validation rules for RssiOffset
		case "tx_enable":
			// no validation rules for TxEnable
		case "tx_freq_min":
			// no validation rules for TxFreqMin
		case "tx_freq_max":
			// no validation rules for TxFreqMax
		case "tx_notch_freq":
			// no validation rules for TxNotchFreq
		default:
			return RFConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// RFConfigValidationError is the validation error returned by
// RFConfig.ValidateFields if the designated constraints aren't met.
type RFConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RFConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RFConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RFConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RFConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RFConfigValidationError) ErrorName() string { return "RFConfigValidationError" }

// Error satisfies the builtin error interface
func (e RFConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRFConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RFConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RFConfigValidationError{}

// ValidateFields checks the field values on IFConfig with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *IFConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = IFConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "enable":
			// no validation rules for Enable
		case "radio":
			// no validation rules for Radio
		case "if_value":
			// no validation rules for IfValue
		case "bandwidth":
			// no validation rules for Bandwidth
		case "spread_factor":
			// no validation rules for SpreadFactor
		case "datarate":
			// no validation rules for Datarate
		default:
			return IFConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// IFConfigValidationError is the validation error returned by
// IFConfig.ValidateFields if the designated constraints aren't met.
type IFConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IFConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IFConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IFConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IFConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IFConfigValidationError) ErrorName() string { return "IFConfigValidationError" }

// Error satisfies the builtin error interface
func (e IFConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIFConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IFConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IFConfigValidationError{}

// ValidateFields checks the field values on TxLUTConfig with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *TxLUTConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = TxLUTConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "pa_gain":
			// no validation rules for PaGain
		case "mix_gain":
			// no validation rules for MixGain
		case "rf_power":
			// no validation rules for RfPower
		case "dig_gain":
			// no validation rules for DigGain
		default:
			return TxLUTConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// TxLUTConfigValidationError is the validation error returned by
// TxLUTConfig.ValidateFields if the designated constraints aren't met.
type TxLUTConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxLUTConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxLUTConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxLUTConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxLUTConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxLUTConfigValidationError) ErrorName() string { return "TxLUTConfigValidationError" }

// Error satisfies the builtin error interface
func (e TxLUTConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxLUTConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxLUTConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxLUTConfigValidationError{}

// ValidateFields checks the field values on SX1301Config with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SX1301Config) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SX1301ConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "lorawan_public":
			// no validation rules for LorawanPublic
		case "clock_source":
			// no validation rules for ClockSource
		case "antenna_gain":
			// no validation rules for AntennaGain
		case "lbt_config":

			if v, ok := interface{}(m.GetLbtConfig()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SX1301ConfigValidationError{
						field:  "lbt_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "radios":

			for idx, item := range m.GetRadios() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return SX1301ConfigValidationError{
							field:  fmt.Sprintf("radios[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "channels":

			for idx, item := range m.GetChannels() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return SX1301ConfigValidationError{
							field:  fmt.Sprintf("channels[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "lora_standard_channel":

			if v, ok := interface{}(m.GetLoraStandardChannel()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SX1301ConfigValidationError{
						field:  "lora_standard_channel",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "fsk_channel":

			if v, ok := interface{}(m.GetFskChannel()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SX1301ConfigValidationError{
						field:  "fsk_channel",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "tx_lut_configs":

			for idx, item := range m.GetTxLutConfigs() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return SX1301ConfigValidationError{
							field:  fmt.Sprintf("tx_lut_configs[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return SX1301ConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// SX1301ConfigValidationError is the validation error returned by
// SX1301Config.ValidateFields if the designated constraints aren't met.
type SX1301ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SX1301ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SX1301ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SX1301ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SX1301ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SX1301ConfigValidationError) ErrorName() string { return "SX1301ConfigValidationError" }

// Error satisfies the builtin error interface
func (e SX1301ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSX1301Config.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SX1301ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SX1301ConfigValidationError{}

// ValidateFields checks the field values on SemtechUDPConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SemtechUDPConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SemtechUDPConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "sx1301_config":

			if v, ok := interface{}(m.GetSx1301Config()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SemtechUDPConfigValidationError{
						field:  "sx1301_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "gateway_config":

			if v, ok := interface{}(m.GetGatewayConfig()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SemtechUDPConfigValidationError{
						field:  "gateway_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return SemtechUDPConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// SemtechUDPConfigValidationError is the validation error returned by
// SemtechUDPConfig.ValidateFields if the designated constraints aren't met.
type SemtechUDPConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SemtechUDPConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SemtechUDPConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SemtechUDPConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SemtechUDPConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SemtechUDPConfigValidationError) ErrorName() string { return "SemtechUDPConfigValidationError" }

// Error satisfies the builtin error interface
func (e SemtechUDPConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSemtechUDPConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SemtechUDPConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SemtechUDPConfigValidationError{}

// ValidateFields checks the field values on LoradConfig with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *LoradConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LoradConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "sx1301_config":

			if v, ok := interface{}(m.GetSx1301Config()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoradConfigValidationError{
						field:  "sx1301_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "gateway_config":

			if v, ok := interface{}(m.GetGatewayConfig()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoradConfigValidationError{
						field:  "gateway_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return LoradConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LoradConfigValidationError is the validation error returned by
// LoradConfig.ValidateFields if the designated constraints aren't met.
type LoradConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoradConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoradConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoradConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoradConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoradConfigValidationError) ErrorName() string { return "LoradConfigValidationError" }

// Error satisfies the builtin error interface
func (e LoradConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoradConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoradConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoradConfigValidationError{}

// ValidateFields checks the field values on LoraFwdConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoraFwdConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LoraFwdConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "gateway":

			if v, ok := interface{}(m.GetGateway()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoraFwdConfigValidationError{
						field:  "gateway",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "filter":

			if v, ok := interface{}(m.GetFilter()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoraFwdConfigValidationError{
						field:  "filter",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "database":

			if v, ok := interface{}(m.GetDatabase()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoraFwdConfigValidationError{
						field:  "database",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "gwmp":

			if v, ok := interface{}(m.GetGwmp()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoraFwdConfigValidationError{
						field:  "gwmp",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "api":

			if v, ok := interface{}(m.GetApi()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoraFwdConfigValidationError{
						field:  "api",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return LoraFwdConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LoraFwdConfigValidationError is the validation error returned by
// LoraFwdConfig.ValidateFields if the designated constraints aren't met.
type LoraFwdConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoraFwdConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoraFwdConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoraFwdConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoraFwdConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoraFwdConfigValidationError) ErrorName() string { return "LoraFwdConfigValidationError" }

// Error satisfies the builtin error interface
func (e LoraFwdConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoraFwdConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoraFwdConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoraFwdConfigValidationError{}

// ValidateFields checks the field values on GatewayInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GatewayInfoResponse) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GatewayInfoResponseFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "id":
			// no validation rules for Id
		case "attributes":

			if v, ok := interface{}(m.GetAttributes()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GatewayInfoResponseValidationError{
						field:  "attributes",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "frequency_plan":
			// no validation rules for FrequencyPlan
		case "frequency_plan_url":
			// no validation rules for FrequencyPlanUrl
		case "auto_update":
			// no validation rules for AutoUpdate
		case "firmware_url":
			// no validation rules for FirmwareUrl
		case "antenna_location":

			if v, ok := interface{}(m.GetAntennaLocation()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GatewayInfoResponseValidationError{
						field:  "antenna_location",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "oauth2_token":

			if v, ok := interface{}(m.GetOauth2Token()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GatewayInfoResponseValidationError{
						field:  "oauth2_token",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "router":

			if v, ok := interface{}(m.GetRouter()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GatewayInfoResponseValidationError{
						field:  "router",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "fallback_routers":

			for idx, item := range m.GetFallbackRouters() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return GatewayInfoResponseValidationError{
							field:  fmt.Sprintf("fallback_routers[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return GatewayInfoResponseValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GatewayInfoResponseValidationError is the validation error returned by
// GatewayInfoResponse.ValidateFields if the designated constraints aren't met.
type GatewayInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayInfoResponseValidationError) ErrorName() string {
	return "GatewayInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayInfoResponseValidationError{}

// ValidateFields checks the field values on PullFrequencyPlanConfigRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *PullFrequencyPlanConfigRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = PullFrequencyPlanConfigRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "frequency_plan_id":
			// no validation rules for FrequencyPlanId
		default:
			return PullFrequencyPlanConfigRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// PullFrequencyPlanConfigRequestValidationError is the validation error
// returned by PullFrequencyPlanConfigRequest.ValidateFields if the designated
// constraints aren't met.
type PullFrequencyPlanConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullFrequencyPlanConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullFrequencyPlanConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullFrequencyPlanConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullFrequencyPlanConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullFrequencyPlanConfigRequestValidationError) ErrorName() string {
	return "PullFrequencyPlanConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PullFrequencyPlanConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullFrequencyPlanConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullFrequencyPlanConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullFrequencyPlanConfigRequestValidationError{}

// ValidateFields checks the field values on SemtechUDPConfig_GatewayConfig
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *SemtechUDPConfig_GatewayConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SemtechUDPConfig_GatewayConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "gateway_id":

			if v, ok := interface{}(m.GetGatewayId()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return SemtechUDPConfig_GatewayConfigValidationError{
						field:  "gateway_id",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "server_address":
			// no validation rules for ServerAddress
		case "server_port_up":
			// no validation rules for ServerPortUp
		case "server_port_down":
			// no validation rules for ServerPortDown
		case "enabled":
			// no validation rules for Enabled
		case "servers":

			for idx, item := range m.GetServers() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return SemtechUDPConfig_GatewayConfigValidationError{
							field:  fmt.Sprintf("servers[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return SemtechUDPConfig_GatewayConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// SemtechUDPConfig_GatewayConfigValidationError is the validation error
// returned by SemtechUDPConfig_GatewayConfig.ValidateFields if the designated
// constraints aren't met.
type SemtechUDPConfig_GatewayConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SemtechUDPConfig_GatewayConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SemtechUDPConfig_GatewayConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SemtechUDPConfig_GatewayConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SemtechUDPConfig_GatewayConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SemtechUDPConfig_GatewayConfigValidationError) ErrorName() string {
	return "SemtechUDPConfig_GatewayConfigValidationError"
}

// Error satisfies the builtin error interface
func (e SemtechUDPConfig_GatewayConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSemtechUDPConfig_GatewayConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SemtechUDPConfig_GatewayConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SemtechUDPConfig_GatewayConfigValidationError{}

// ValidateFields checks the field values on LoradConfig_LoradSX1301Config with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *LoradConfig_LoradSX1301Config) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LoradConfig_LoradSX1301ConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "global_config":

			if v, ok := interface{}(m.GetGlobalConfig()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return LoradConfig_LoradSX1301ConfigValidationError{
						field:  "global_config",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "insertion_loss":
			// no validation rules for InsertionLoss
		case "insertion_loss_desc":
			// no validation rules for InsertionLossDesc
		case "antenna_gain_desc":
			// no validation rules for AntennaGainDesc
		default:
			return LoradConfig_LoradSX1301ConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LoradConfig_LoradSX1301ConfigValidationError is the validation error
// returned by LoradConfig_LoradSX1301Config.ValidateFields if the designated
// constraints aren't met.
type LoradConfig_LoradSX1301ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoradConfig_LoradSX1301ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoradConfig_LoradSX1301ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoradConfig_LoradSX1301ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoradConfig_LoradSX1301ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoradConfig_LoradSX1301ConfigValidationError) ErrorName() string {
	return "LoradConfig_LoradSX1301ConfigValidationError"
}

// Error satisfies the builtin error interface
func (e LoradConfig_LoradSX1301ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoradConfig_LoradSX1301Config.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoradConfig_LoradSX1301ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoradConfig_LoradSX1301ConfigValidationError{}

// ValidateFields checks the field values on LoradConfig_GatewayConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoradConfig_GatewayConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LoradConfig_GatewayConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "beacon_enable":
			// no validation rules for BeaconEnable
		case "beacon_period":
			// no validation rules for BeaconPeriod
		case "beacon_freq_hz":
			// no validation rules for BeaconFreqHz
		case "beacon_freq_nb":
			// no validation rules for BeaconFreqNb
		case "beacon_step":
			// no validation rules for BeaconStep
		case "beacon_datarate":
			// no validation rules for BeaconDatarate
		case "beacon_bw_hz":
			// no validation rules for BeaconBwHz
		case "beacon_power":
			// no validation rules for BeaconPower
		case "beacon_infodesc":
			// no validation rules for BeaconInfodesc
		case "beacon_latitude":
			// no validation rules for BeaconLatitude
		case "beacon_longitude":
			// no validation rules for BeaconLongitude
		default:
			return LoradConfig_GatewayConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LoradConfig_GatewayConfigValidationError is the validation error returned by
// LoradConfig_GatewayConfig.ValidateFields if the designated constraints
// aren't met.
type LoradConfig_GatewayConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoradConfig_GatewayConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoradConfig_GatewayConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoradConfig_GatewayConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoradConfig_GatewayConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoradConfig_GatewayConfigValidationError) ErrorName() string {
	return "LoradConfig_GatewayConfigValidationError"
}

// Error satisfies the builtin error interface
func (e LoradConfig_GatewayConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoradConfig_GatewayConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoradConfig_GatewayConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoradConfig_GatewayConfigValidationError{}

// ValidateFields checks the field values on LoraFwdConfig_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoraFwdConfig_Filter) ValidateFields(paths ...string) error {
	if len(paths) > 0 {
		return fmt.Errorf("message LoraFwdConfig_Filter has no fields, but paths %s were specified", paths)
	}
	return nil
}

// LoraFwdConfig_FilterValidationError is the validation error returned by
// LoraFwdConfig_Filter.ValidateFields if the designated constraints aren't met.
type LoraFwdConfig_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoraFwdConfig_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoraFwdConfig_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoraFwdConfig_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoraFwdConfig_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoraFwdConfig_FilterValidationError) ErrorName() string {
	return "LoraFwdConfig_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e LoraFwdConfig_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoraFwdConfig_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoraFwdConfig_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoraFwdConfig_FilterValidationError{}

// ValidateFields checks the field values on LoraFwdConfig_Database with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoraFwdConfig_Database) ValidateFields(paths ...string) error {
	if len(paths) > 0 {
		return fmt.Errorf("message LoraFwdConfig_Database has no fields, but paths %s were specified", paths)
	}
	return nil
}

// LoraFwdConfig_DatabaseValidationError is the validation error returned by
// LoraFwdConfig_Database.ValidateFields if the designated constraints aren't met.
type LoraFwdConfig_DatabaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoraFwdConfig_DatabaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoraFwdConfig_DatabaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoraFwdConfig_DatabaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoraFwdConfig_DatabaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoraFwdConfig_DatabaseValidationError) ErrorName() string {
	return "LoraFwdConfig_DatabaseValidationError"
}

// Error satisfies the builtin error interface
func (e LoraFwdConfig_DatabaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoraFwdConfig_Database.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoraFwdConfig_DatabaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoraFwdConfig_DatabaseValidationError{}

// ValidateFields checks the field values on LoraFwdConfig_GWMPConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoraFwdConfig_GWMPConfig) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = LoraFwdConfig_GWMPConfigFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "node":
			// no validation rules for Node
		case "service_uplink":
			// no validation rules for ServiceUplink
		case "service_downlink":
			// no validation rules for ServiceDownlink
		default:
			return LoraFwdConfig_GWMPConfigValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// LoraFwdConfig_GWMPConfigValidationError is the validation error returned by
// LoraFwdConfig_GWMPConfig.ValidateFields if the designated constraints
// aren't met.
type LoraFwdConfig_GWMPConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoraFwdConfig_GWMPConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoraFwdConfig_GWMPConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoraFwdConfig_GWMPConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoraFwdConfig_GWMPConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoraFwdConfig_GWMPConfigValidationError) ErrorName() string {
	return "LoraFwdConfig_GWMPConfigValidationError"
}

// Error satisfies the builtin error interface
func (e LoraFwdConfig_GWMPConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoraFwdConfig_GWMPConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoraFwdConfig_GWMPConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoraFwdConfig_GWMPConfigValidationError{}

// ValidateFields checks the field values on LoraFwdConfig_API with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoraFwdConfig_API) ValidateFields(paths ...string) error {
	if len(paths) > 0 {
		return fmt.Errorf("message LoraFwdConfig_API has no fields, but paths %s were specified", paths)
	}
	return nil
}

// LoraFwdConfig_APIValidationError is the validation error returned by
// LoraFwdConfig_API.ValidateFields if the designated constraints aren't met.
type LoraFwdConfig_APIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoraFwdConfig_APIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoraFwdConfig_APIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoraFwdConfig_APIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoraFwdConfig_APIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoraFwdConfig_APIValidationError) ErrorName() string {
	return "LoraFwdConfig_APIValidationError"
}

// Error satisfies the builtin error interface
func (e LoraFwdConfig_APIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoraFwdConfig_API.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoraFwdConfig_APIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoraFwdConfig_APIValidationError{}

// ValidateFields checks the field values on GatewayInfoResponse_Attributes
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *GatewayInfoResponse_Attributes) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GatewayInfoResponse_AttributesFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "description":
			// no validation rules for Description
		default:
			return GatewayInfoResponse_AttributesValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GatewayInfoResponse_AttributesValidationError is the validation error
// returned by GatewayInfoResponse_Attributes.ValidateFields if the designated
// constraints aren't met.
type GatewayInfoResponse_AttributesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayInfoResponse_AttributesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayInfoResponse_AttributesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayInfoResponse_AttributesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayInfoResponse_AttributesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayInfoResponse_AttributesValidationError) ErrorName() string {
	return "GatewayInfoResponse_AttributesValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayInfoResponse_AttributesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayInfoResponse_Attributes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayInfoResponse_AttributesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayInfoResponse_AttributesValidationError{}

// ValidateFields checks the field values on
// GatewayInfoResponse_AntennaLocation with the rules defined in the proto
// definition for this message. If any rules are violated, an error is returned.
func (m *GatewayInfoResponse_AntennaLocation) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GatewayInfoResponse_AntennaLocationFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "latitude":
			// no validation rules for Latitude
		case "longitude":
			// no validation rules for Longitude
		case "Altitude":
			// no validation rules for Altitude
		default:
			return GatewayInfoResponse_AntennaLocationValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GatewayInfoResponse_AntennaLocationValidationError is the validation error
// returned by GatewayInfoResponse_AntennaLocation.ValidateFields if the
// designated constraints aren't met.
type GatewayInfoResponse_AntennaLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayInfoResponse_AntennaLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayInfoResponse_AntennaLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayInfoResponse_AntennaLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayInfoResponse_AntennaLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayInfoResponse_AntennaLocationValidationError) ErrorName() string {
	return "GatewayInfoResponse_AntennaLocationValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayInfoResponse_AntennaLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayInfoResponse_AntennaLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayInfoResponse_AntennaLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayInfoResponse_AntennaLocationValidationError{}

// ValidateFields checks the field values on GatewayInfoResponse_OAuth2Token
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *GatewayInfoResponse_OAuth2Token) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GatewayInfoResponse_OAuth2TokenFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "access_token":
			// no validation rules for AccessToken
		case "expires_in":
			// no validation rules for ExpiresIn
		default:
			return GatewayInfoResponse_OAuth2TokenValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GatewayInfoResponse_OAuth2TokenValidationError is the validation error
// returned by GatewayInfoResponse_OAuth2Token.ValidateFields if the
// designated constraints aren't met.
type GatewayInfoResponse_OAuth2TokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayInfoResponse_OAuth2TokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayInfoResponse_OAuth2TokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayInfoResponse_OAuth2TokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayInfoResponse_OAuth2TokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayInfoResponse_OAuth2TokenValidationError) ErrorName() string {
	return "GatewayInfoResponse_OAuth2TokenValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayInfoResponse_OAuth2TokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayInfoResponse_OAuth2Token.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayInfoResponse_OAuth2TokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayInfoResponse_OAuth2TokenValidationError{}

// ValidateFields checks the field values on GatewayInfoResponse_Router with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *GatewayInfoResponse_Router) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GatewayInfoResponse_RouterFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "id":
			// no validation rules for Id
		case "mqtt_address":
			// no validation rules for MqttAddress
		default:
			return GatewayInfoResponse_RouterValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GatewayInfoResponse_RouterValidationError is the validation error returned
// by GatewayInfoResponse_Router.ValidateFields if the designated constraints
// aren't met.
type GatewayInfoResponse_RouterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GatewayInfoResponse_RouterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GatewayInfoResponse_RouterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GatewayInfoResponse_RouterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GatewayInfoResponse_RouterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GatewayInfoResponse_RouterValidationError) ErrorName() string {
	return "GatewayInfoResponse_RouterValidationError"
}

// Error satisfies the builtin error interface
func (e GatewayInfoResponse_RouterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGatewayInfoResponse_Router.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GatewayInfoResponse_RouterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GatewayInfoResponse_RouterValidationError{}
